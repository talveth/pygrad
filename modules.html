<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Modules &#8212; pygrad 0.0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=f6a572b4" />
    <script src="_static/documentation_options.js?v=d45e8c67"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Examples" href="examples.html" />
    <link rel="prev" title="Usage" href="usage.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">pygrad</a></h1>



<p class="blurb">A lightweight differentiation engine written in Python.</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=baubels&repo=pygrad&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="usage.html">Usage</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Modules</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#tensor">tensor</a></li>
<li class="toctree-l2"><a class="reference internal" href="#basics-activations-and-losses">basics, activations, and losses</a></li>
<li class="toctree-l2"><a class="reference internal" href="#optims">optims</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module">module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="methods.html">Class methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="contrib.html">Contributions/Problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="about.html">About me</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="usage.html" title="previous chapter">Usage</a></li>
      <li>Next: <a href="examples.html" title="next chapter">Examples</a></li>
  </ul></li>
</ul>
</div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="modules">
<span id="id1"></span><h1>Modules<a class="headerlink" href="#modules" title="Link to this heading">¶</a></h1>
<section id="tensor">
<span id="id2"></span><h2>tensor<a class="headerlink" href="#tensor" title="Link to this heading">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">tensor</span></code> module contains the main <cite>Tensor</cite> class responsible for providing automatic differentiation capability.</p>
<p>The <cite>Tensor</cite> object is a NumPy array holding gradients, supporting a variety of common operations, computing gradients when request.</p>
<section id="values-and-gradients">
<h3>Values and Gradients<a class="headerlink" href="#values-and-gradients" title="Link to this heading">¶</a></h3>
<p>In its simplest form, <cite>Tensors</cite> are initialized with a <cite>value</cite>.
Values accepted are (non-complex) numeric types, lists, and NumPy arrays.:</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">)))</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
<p>Gradients of each <cite>Tensor</cite> are initialized <code class="docutils literal notranslate"><span class="pre">0</span></code>, stored in <code class="docutils literal notranslate"><span class="pre">.grad</span></code>, and are of the same shape as the passed-in <code class="docutils literal notranslate"><span class="pre">value</span></code>.
Gradients are <code class="docutils literal notranslate"><span class="pre">0</span></code> until backpropagation is manually called upon either the Tensor or a referee:</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">grad</span><span class="p">)</span>
<span class="c1"># -&gt; 1.0 0.0</span>
</pre></div>
</div>
</section>
<section id="operations-and-topological-graphs">
<h3>Operations and Topological Graphs<a class="headerlink" href="#operations-and-topological-graphs" title="Link to this heading">¶</a></h3>
<p><cite>Tensors</cite> support a variety of operations as methods:</p>
<blockquote>
<div><ul class="simple">
<li><p>dunder methods: __add__, __sub__, __neg__, __truediv__, __mul__, __matmul__, __pow__</p></li>
<li><p>other common ops: sum, reshape, transpose, T, mean, std, conv2D, mask_idcs</p></li>
<li><p>activations: relu, tanh, sigmoid, softmax</p></li>
<li><p>NumPy-level broadcasting and slicing</p></li>
</ul>
</div></blockquote>
<p>For example, the below are all valid:</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">)))</span>

<span class="c1"># built-ins</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="nd">@np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">20</span><span class="p">))</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">))</span>      <span class="c1"># broadcasting is performed</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">20</span><span class="p">)))</span> <span class="o">**</span><span class="mi">2</span>

<span class="c1"># other</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">));</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">+</span> <span class="n">x</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">transpose</span><span class="p">();</span> <span class="n">x</span><span class="o">.</span><span class="n">T</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">30</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="n">x2</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">))</span>
<span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">kH</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">kW</span><span class="o">=</span><span class="mi">5</span><span class="p">))</span>
<span class="n">kernel</span><span class="o">.</span><span class="n">Conv2D</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>

<span class="c1"># activations</span>
<span class="n">x</span><span class="o">.</span><span class="n">relu</span><span class="p">()</span>
<span class="n">x</span><span class="o">.</span><span class="n">tanh</span><span class="p">()</span>
<span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">()</span>
<span class="n">x</span><span class="o">.</span><span class="n">softmax</span><span class="p">()</span>
</pre></div>
</div>
<p>Applying an operation on a <cite>Tensor</cite> will always produce a new Tensor whose operands are those Tensors’ children.
By applying successive operations on a <cite>Tensor</cite>, a computational graph is built and stored, thus, each <cite>Tensor</cite>
has memory of the <cite>Tensors</cite> used to create it. The direct children of a Tensor can be found in its <code class="docutils literal notranslate"><span class="pre">._prev</span></code> attribute.</p>
<p>A <cite>Tensor</cite>’s computational graph can be generated at any point in time with <cite>.create_graph()</cite>.
This method returns two computational graphs: a complete topological graph, <code class="docutils literal notranslate"><span class="pre">topo</span></code> and a weights-only graph <code class="docutils literal notranslate"><span class="pre">weights</span></code>.</p>
<p>Both graphs are reverse-ordered (pre-order traversed) lists of operands performed on <cite>self</cite>, with <cite>self</cite> as root.</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">topo</span></code> stores all Tensors that interacted to produce the Tensor.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">weights</span></code> only Tensors with learnable weights that produced the Tensor.</p></li>
</ul>
</div></blockquote>
<p>The following illustrates their difference:</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">topo</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">create_graph</span><span class="p">()</span>
</pre></div>
</div>
<p>In the above, 3 operations are performed on a created Tensor <code class="docutils literal notranslate"><span class="pre">x</span></code>, thus, <code class="docutils literal notranslate"><span class="pre">topo</span></code> is a list with the following
elements in this order:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">x**2</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">x**2</span> <span class="pre">+</span> <span class="pre">x</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">y=x**2</span> <span class="pre">+</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></code></p></li>
</ol>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">weights</span></code> however only contains the <code class="docutils literal notranslate"><span class="pre">x</span></code> Tensor, as in producing <code class="docutils literal notranslate"><span class="pre">y</span></code>,
only one Tensor had learnable weights, with all intermediary Tensors not contributing uniquely to <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
</section>
<section id="backwards-propagation">
<h3>Backwards propagation<a class="headerlink" href="#backwards-propagation" title="Link to this heading">¶</a></h3>
<p>Having a set of <code class="docutils literal notranslate"><span class="pre">weights</span></code> for a Tensor allows performing backpropagation on that Tensor,
updating only those Tensors whose values directly contribute, ignoring the rest.
This is how <code class="docutils literal notranslate"><span class="pre">backward()</span></code> is implemented in the library.</p>
<p>Backpropagation can be directly performed on a Tensor at any time using the <code class="docutils literal notranslate"><span class="pre">.backward()</span></code> method.
This populates the gradients of all contibuting weights to that Tensor.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">y</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">grad</span><span class="p">)</span>
<span class="c1"># -&gt; 3.0</span>
<span class="n">y</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">grad</span><span class="p">)</span>
<span class="c1"># -&gt; 3.0</span>
<span class="n">y</span><span class="o">.</span><span class="n">backward</span><span class="p">(</span><span class="n">reset_grad</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">grad</span><span class="p">)</span>
<span class="c1"># -&gt; 11.0</span>
</pre></div>
</div>
<p>Backprop can be applied as many times as needed on a Tensor, however will default to resetting all previous backwards passes.
To perform backpropagation multiple times on the same computational graph, set <code class="docutils literal notranslate"><span class="pre">reset_grad=False</span></code>.
Each new backprop adds the previous gradients to the new one, using these added gradients for gradient
computations further down the computational graph.</p>
</section>
<section id="gradient-descent-example">
<h3>Gradient Descent example<a class="headerlink" href="#gradient-descent-example" title="Link to this heading">¶</a></h3>
<p>The following shows a simple example of performing gradient descent on the Tensor <code class="docutils literal notranslate"><span class="pre">x=1</span></code>.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">pygrad.tensor</span><span class="w"> </span><span class="kn">import</span> <span class="n">Tensor</span>

<span class="n">n_iters</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">stepsize</span><span class="o">=</span> <span class="mf">0.01</span>
<span class="n">x</span>       <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_iters</span><span class="p">):</span>
    <span class="n">loss_fn</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mf">1.5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">loss_fn</span><span class="o">.</span><span class="n">backward</span><span class="p">(</span><span class="n">reset_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">x</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="n">stepsize</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">grad</span>

<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">loss_fn</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="c1"># -&gt; 1.4336... 0.0045...</span>
</pre></div>
</div>
<p>For performing backprop automatically with more complex functions, use the <a class="reference internal" href="#optims"><span class="std std-ref">optims</span></a> module.
Vectorized backprop with batched data is also supported, however to not modify the underlying model
whilst performing vectorized forward and backwards passes will require creating a subclass of <code class="docutils literal notranslate"><span class="pre">Module</span></code>.</p>
<p>For all Tensor methods see: <a class="reference internal" href="methods.html#tensormethods"><span class="std std-ref">Tensor Methods</span></a></p>
</section>
</section>
<section id="basics-activations-and-losses">
<span id="basics"></span><h2>basics, activations, and losses<a class="headerlink" href="#basics-activations-and-losses" title="Link to this heading">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">basics,</span> <span class="pre">activations,</span> <span class="pre">and</span> <span class="pre">losses</span></code> modules extend the functionality of the <code class="docutils literal notranslate"><span class="pre">Tensor</span></code>, by providing Pytorch-like classes
that create a variety of higher-order Tensors commonly used in deep-learning.</p>
<p>These include:</p>
<blockquote>
<div><ul class="simple">
<li><p>Dropout, AddNorm, Linear, Softmax, Flatten, Conv2D layers,</p></li>
<li><p>ReLU activation,</p></li>
<li><p>BCELoss, CCELoss losses.</p></li>
</ul>
</div></blockquote>
<p>The above classes contain no dependencies other than the <code class="docutils literal notranslate"><span class="pre">Tensor</span></code> object and <code class="docutils literal notranslate"><span class="pre">NumPy</span></code>.
Since <code class="docutils literal notranslate"><span class="pre">Tensors``s</span> <span class="pre">use</span> <span class="pre">``NumPy</span></code> arrays under the hood, creating custom classes is thus very simple.
For example, defining Dropout is done as follows:</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">pygrad.tensor</span><span class="w"> </span><span class="kn">import</span> <span class="n">Tensor</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Dropout</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rate</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rate</span> <span class="o">=</span> <span class="n">rate</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">training</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">training</span><span class="p">:</span>
            <span class="n">n_points</span>        <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">rate</span><span class="p">)</span>
            <span class="n">arr_indices</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)),</span>
                                                <span class="n">size</span><span class="o">=</span><span class="n">n_points</span><span class="p">,</span>
                                                <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">dropouted_pts</span>   <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">mask_idcs</span><span class="p">(</span><span class="n">arr_indices</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">dropouted_pts</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>
</pre></div>
</div>
<p>Backpropagation can now be done using this Class, no different than with any other Tensor:</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">Dropout</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">otp</span> <span class="o">=</span> <span class="n">d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">otp</span><span class="o">.</span><span class="n">value</span>
<span class="c1"># -&gt; array([1., 0., 0., 1.])</span>
<span class="n">otp</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
<span class="n">x</span><span class="o">.</span><span class="n">grad</span>
<span class="c1"># -&gt; array([1., 0., 0., 1.])</span>
</pre></div>
</div>
<p>For all methods in basics, activations, and losses, see: <a class="reference internal" href="methods.html#basics-methods"><span class="std std-ref">basics, activations, losses</span></a>.</p>
</section>
<section id="optims">
<span id="id3"></span><h2>optims<a class="headerlink" href="#optims" title="Link to this heading">¶</a></h2>
<p>Classes for gradient descent such as SGD, SGD with Momentum, RMSProp, and Adam are defined here.
Optimizers are designed to work with the <code class="docutils literal notranslate"><span class="pre">weights</span></code> of a Tensor (called a <code class="docutils literal notranslate"><span class="pre">model</span></code>), each having a <code class="docutils literal notranslate"><span class="pre">.zero_grad</span></code> method
for resetting Tensor gradients, a <code class="docutils literal notranslate"><span class="pre">.step</span></code> method for updating model weights given a loss function, and a <code class="docutils literal notranslate"><span class="pre">.step_single</span></code> method
for updating model weights progressively in a memory-sensitive manner when model weights are large.
This method is further explained under <a class="reference internal" href="#module"><span class="std std-ref">module</span></a>.</p>
<p>Basic usage is the same across all optimizers;
initialize the optimizer with the model weights along with optimizer-specific parameters;
reset the model gradient;
do a forward pass and a backwards pass with a specified loss function;
and step with the optimizer, feeding in the loss function.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">pygrad.tensor</span><span class="w"> </span><span class="kn">import</span> <span class="n">Tensor</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pygrad.optims</span><span class="w"> </span><span class="kn">import</span> <span class="n">SGD</span>

<span class="n">x</span>     <span class="o">=</span> <span class="n">Tensor</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="n">y</span>     <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">create_graph</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>                <span class="c1"># fetching .weights from Tensor y</span>
<span class="n">optim</span> <span class="o">=</span> <span class="n">SGD</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">lr</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>

<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">optim</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
    <span class="n">y</span>    <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="mf">1.5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
    <span class="n">optim</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">loss</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="c1"># -&gt; 0.7100436 1.50433688 1.88085134e-05</span>
</pre></div>
</div>
<p>For all available options, see: <a class="reference internal" href="methods.html#optimsmethods"><span class="std std-ref">optims options</span></a>.</p>
</section>
<section id="module">
<span id="id4"></span><h2>module<a class="headerlink" href="#module" title="Link to this heading">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">Module</span></code> class gives the ability to perform batched forward and backward passes on the model without mutating the model.
Functions defined as classes representing models can also easily use optimizers as defined in <a class="reference internal" href="#optims"><span class="std std-ref">optims</span></a>.</p>
<p>Below shows how to convert a class-defined function into one subclassing <code class="docutils literal notranslate"><span class="pre">Module</span></code>.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">DNN</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Dense Neural Network, (28,28) -&gt; (10) &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>          <span class="o">=</span> <span class="n">dtype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span>        <span class="o">=</span> <span class="n">Flatten</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dense1</span>         <span class="o">=</span> <span class="n">Linear</span><span class="p">(</span><span class="n">i_dim</span><span class="o">=</span><span class="mi">28</span><span class="o">*</span><span class="mi">28</span><span class="p">,</span> <span class="n">o_dim</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relu1</span>          <span class="o">=</span> <span class="n">ReLU</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dense2</span>         <span class="o">=</span> <span class="n">Linear</span><span class="p">(</span><span class="n">i_dim</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">o_dim</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span><span class="n">Tensor</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dense1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relu1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dense2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>
</pre></div>
</div>
<dl class="simple">
<dt>The following have to now take place:</dt><dd><ol class="arabic simple">
<li><p>Subclassing (<code class="docutils literal notranslate"><span class="pre">pygrad.module.Module</span></code>)</p></li>
<li><dl class="simple">
<dt>A line <code class="docutils literal notranslate"><span class="pre">super().__init__</span></code>, passing in the expected model forward-pass inputs, with:</dt><dd><ul class="simple">
<li><p>each input that is of type <code class="docutils literal notranslate"><span class="pre">Tensor</span></code> has to have set <code class="docutils literal notranslate"><span class="pre">leaf=True</span></code></p></li>
</ul>
</dd>
</dl>
</li>
<li><p>Any calling of the model that has <code class="docutils literal notranslate"><span class="pre">Tensor</span></code> inputs requires the tensor to have <code class="docutils literal notranslate"><span class="pre">leaf=True</span></code></p></li>
<li><p>Any calling of the model requires keyword inputs.</p></li>
</ol>
</dd>
</dl>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">DNN2</span><span class="p">(</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">PRECISION</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>          <span class="o">=</span> <span class="n">dtype</span>
        <span class="n">batch_size</span>          <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span>        <span class="o">=</span> <span class="n">Flatten</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dense1</span>         <span class="o">=</span> <span class="n">Linear</span><span class="p">(</span><span class="n">i_dim</span><span class="o">=</span><span class="mi">28</span><span class="o">*</span><span class="mi">28</span><span class="p">,</span> <span class="n">o_dim</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relu1</span>          <span class="o">=</span> <span class="n">ReLU</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dense2</span>         <span class="o">=</span> <span class="n">Linear</span><span class="p">(</span><span class="n">i_dim</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">o_dim</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">Tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">batch_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">leaf</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span><span class="n">Tensor</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dense1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relu1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dense2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>
</pre></div>
</div>
<p>By subclassing, model forward passes can be performed by calling the model on the needed inputs,
ensuring that all input keyword arguments are specified:</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">DNN2</span><span class="p">()</span>
<span class="n">model</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<p>The below now illustrates the difference:</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">dnn1</span>    <span class="o">=</span> <span class="n">DNN</span><span class="p">()</span>
<span class="n">dnn2</span>    <span class="o">=</span> <span class="n">DNN2</span><span class="p">()</span>

<span class="n">batch_size</span> <span class="o">=</span> <span class="mi">16</span>
<span class="n">x</span>          <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">batch_size</span><span class="p">,</span><span class="mi">28</span><span class="p">,</span><span class="mi">28</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">leaf</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">fwd1</span>    <span class="o">=</span> <span class="n">dnn1</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>   <span class="c1"># shape=(batch_size, 1, 10)</span>
<span class="n">fwd2</span>    <span class="o">=</span> <span class="n">dnn2</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>         <span class="c1"># shape=(batch_size, 1, 10)</span>

<span class="n">fwd1</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
<span class="n">fwd2</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>

<span class="n">dnn1</span><span class="o">.</span><span class="n">dense2</span><span class="o">.</span><span class="n">W</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dnn2</span><span class="o">.</span><span class="n">dense2</span><span class="o">.</span><span class="n">W</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span>
<span class="c1"># -&gt; ((batch_size, 100, 10), (1, 100, 10))</span>
<span class="n">dnn1</span><span class="o">.</span><span class="n">dense2</span><span class="o">.</span><span class="n">W</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dnn2</span><span class="o">.</span><span class="n">dense2</span><span class="o">.</span><span class="n">W</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">shape</span>
<span class="c1"># -&gt; ((batch_size, 100, 10), (1, 100, 10))</span>
</pre></div>
</div>
<p>Both versions are able to apply batched forward passes on the input.
However, due to Tensor automatically rescaling due to broadcasting, only the model subclassing <code class="docutils literal notranslate"><span class="pre">Module</span></code>
is able to maintain the originally instantiated shape of values and gradients.</p>
<p>Performing gradient descent on the original model would require resetting values and gradient shapes
of each model weight, and updating gradients according to the batched versions, undoing any broadcasting.
This process is done automatically when subclassing <code class="docutils literal notranslate"><span class="pre">Module</span></code>, with the batched copy of the <code class="docutils literal notranslate"><span class="pre">model</span></code>
available under <code class="docutils literal notranslate"><span class="pre">model.copy</span></code>.</p>
<p>Using <code class="docutils literal notranslate"><span class="pre">Module</span></code> makes it easy to perform gradient descent with <a class="reference internal" href="#optims"><span class="std std-ref">optims</span></a>:</p>
<blockquote>
<div><ul class="simple">
<li><p>Model weights are found in <code class="docutils literal notranslate"><span class="pre">model.weights</span></code>. These weights are given to the optimizer for updating.</p></li>
<li><p>Batched model data which is stored in the model after calling on batched data is reset with <code class="docutils literal notranslate"><span class="pre">model.model_reset()</span></code>. If this is not reset, the previous model gradients will accumulate. This will also stop the model from training if different batch sizes are given from one training epoch from the next.</p></li>
</ul>
</div></blockquote>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">pygrad.tensor</span><span class="w"> </span><span class="kn">import</span> <span class="n">Tensor</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pygrad.optims</span><span class="w"> </span><span class="kn">import</span> <span class="n">SGD</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">model</span>       <span class="o">=</span> <span class="n">DNN2</span><span class="p">()</span>                        <span class="c1"># defined previously, subclassing Module</span>
<span class="n">optim</span>       <span class="o">=</span> <span class="n">SGD</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">weights</span><span class="p">,</span> <span class="n">lr</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>    <span class="c1"># model.weights property is available</span>

<span class="n">n_epochs</span>    <span class="o">=</span> <span class="mi">25</span>
<span class="n">batch_size</span>  <span class="o">=</span> <span class="mi">4</span>

<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_epochs</span><span class="p">):</span>
    <span class="n">x</span>           <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,(</span><span class="n">batch_size</span><span class="p">,</span><span class="mi">28</span><span class="p">,</span><span class="mi">28</span><span class="p">)),</span> <span class="n">leaf</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">y_true</span>      <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">batch_size</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">leaf</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">model</span><span class="o">.</span><span class="n">model_reset</span><span class="p">()</span>
    <span class="n">optim</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
    <span class="n">y_pred</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>
    <span class="n">loss</span>   <span class="o">=</span> <span class="p">((</span><span class="n">y_pred</span> <span class="o">-</span> <span class="n">y_true</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="c1"># averages over the batch</span>
    <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
    <span class="n">optim</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span>
</pre></div>
</div>
<p>The model’s weights will be updated here according to losses averaged over the batch, but without any change to their originally defined shape.
For more training examples, see <a class="reference internal" href="examples.html#examples"><span class="std std-ref">Examples</span></a>.</p>
<p>For class methods, see <a class="reference internal" href="methods.html#module-methods"><span class="std std-ref">Module</span></a></p>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;2024, Danila Kurganov.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/modules.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    
    <a href="https://github.com/baubels/pygrad" class="github">
        <img src="_static/github-banner.svg" alt="Fork me on GitHub" class="github"/>
    </a>
    

    
  </body>
</html>